(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{506:function(t,a,_){"use strict";_.r(a);var v=_(5),e=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[_("RouterLink",{attrs:{to:"/views/notebook/jvm/class-code-instructions.html"}},[t._v("点击查看虚拟机字节码指令表")])],1),t._v(" "),_("h2",{attrs:{id:"加载和存储指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#加载和存储指令"}},[t._v("#")]),t._v(" 加载和存储指令")]),t._v(" "),_("blockquote",[_("p",[t._v("load aload")]),t._v(" "),_("p",[t._v("push")]),t._v(" "),_("p",[t._v("const")]),t._v(" "),_("p",[t._v("ldc ldc_w ldc2_w")])]),t._v(" "),_("h2",{attrs:{id:"运算指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运算指令"}},[t._v("#")]),t._v(" 运算指令")]),t._v(" "),_("blockquote",[_("p",[t._v("add sub mul div")]),t._v(" "),_("p",[t._v("rem")]),t._v(" "),_("p",[t._v("neg")]),t._v(" "),_("p",[t._v("and or xor")]),t._v(" "),_("p",[t._v("shl shr nshl nshr")]),t._v(" "),_("p",[t._v("cmp")])]),t._v(" "),_("h2",{attrs:{id:"类型转换指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类型转换指令"}},[t._v("#")]),t._v(" 类型转换指令")]),t._v(" "),_("blockquote",[_("ul",[_("li",[t._v("宽化类型转换 :\n"),_("ul",[_("li",[t._v("int类型到long、float或者double类型")]),t._v(" "),_("li",[t._v("long类型到float、double类型")]),t._v(" "),_("li",[t._v("float类型到double类型")])])]),t._v(" "),_("li",[t._v("窄化类型转换 :\n"),_("ul",[_("li",[t._v("i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f")])])])])]),t._v(" "),_("h2",{attrs:{id:"对象创建与访问指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象创建与访问指令"}},[t._v("#")]),t._v(" 对象创建与访问指令")]),t._v(" "),_("blockquote",[_("p",[t._v("创建类实例的指令：new")]),t._v(" "),_("p",[t._v("创建数组的指令: newarray、anewarray、multianewarray")]),t._v(" "),_("p",[t._v("访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic")]),t._v(" "),_("p",[t._v("把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload")]),t._v(" "),_("p",[t._v("将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore")]),t._v(" "),_("p",[t._v("取数组长度的指令：arraylength")]),t._v(" "),_("p",[t._v("检查类实例类型的指令：instanceof、checkcast")])]),t._v(" "),_("h2",{attrs:{id:"操作数栈管理指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#操作数栈管理指令"}},[t._v("#")]),t._v(" 操作数栈管理指令")]),t._v(" "),_("blockquote",[_("p",[t._v("将操作数栈的栈顶一个或两个元素出栈：pop、pop2")]),t._v(" "),_("p",[t._v("复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2")]),t._v(" "),_("p",[t._v("将栈最顶端的两个数值互换：swap")])]),t._v(" "),_("h2",{attrs:{id:"控制转移指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#控制转移指令"}},[t._v("#")]),t._v(" 控制转移指令")]),t._v(" "),_("blockquote",[_("p",[t._v("条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne")]),t._v(" "),_("p",[t._v("复合条件分支：tableswitch、lookupswitch")]),t._v(" "),_("p",[t._v("无条件分支：goto、goto_w、jsr、jsr_w、ret")])]),t._v(" "),_("h2",{attrs:{id:"方法调用和返回指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法调用和返回指令"}},[t._v("#")]),t._v(" 方法调用和返回指令")]),t._v(" "),_("blockquote",[_("p",[t._v("invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。")]),t._v(" "),_("p",[t._v("invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。")]),t._v(" "),_("p",[t._v("invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。")]),t._v(" "),_("p",[t._v("invokestatic指令：用于调用类静态方法（static方法）")]),t._v(" "),_("p",[t._v("invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的")]),t._v(" "),_("p",[t._v("方法返回指令")]),t._v(" "),_("ul",[_("li",[t._v("根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn")]),t._v(" "),_("li",[t._v("另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用")])])]),t._v(" "),_("h2",{attrs:{id:"异常处理指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异常处理指令"}},[t._v("#")]),t._v(" 异常处理指令")]),t._v(" "),_("blockquote",[_("p",[t._v("已经不用指令来处理了, 而是用异常表来完成")])]),t._v(" "),_("h2",{attrs:{id:"同步指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同步指令"}},[t._v("#")]),t._v(" 同步指令")]),t._v(" "),_("blockquote",[_("p",[t._v("方法级的同步是隐式的，无须通过字节码指令来控制")]),t._v(" "),_("p",[t._v("monitorenter + monitorexit 对标记了 synchronized 的方法线程进行管程 (Monitor，更常见的是直接将它称为“锁”) 操作")])])])}),[],!1,null,null,null);a.default=e.exports}}]);