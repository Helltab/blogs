(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{466:function(t,s,v){t.exports=v.p+"assets/img/1212121212121.0b7a02fb.png"},528:function(t,s,v){"use strict";v.r(s);var _=v(5),e=Object(_.a)({},(function(){var t=this,s=t.$createElement,_=t._self._c||s;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("blockquote",[_("p",[t._v("考察点: 安全性, 性能, 单点登录, 多点登录")])]),t._v(" "),_("h2",{attrs:{id:"session-认证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#session-认证"}},[t._v("#")]),t._v(" session 认证")]),t._v(" "),_("blockquote",[_("p",[t._v("将认证信息存放在 session 中, 根据请求的 sessionId 来判断是否认证")]),t._v(" "),_("p",[t._v("分布式系统需要共享 session")]),t._v(" "),_("p",[t._v("对移动端不友好")])]),t._v(" "),_("h2",{attrs:{id:"jwt-认证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jwt-认证"}},[t._v("#")]),t._v(" jwt 认证")]),t._v(" "),_("blockquote",[_("ol",[_("li",[t._v("服务器通过算法签发一个无状态的 jwt")]),t._v(" "),_("li",[t._v("前端每次请求都携带 jwt")]),t._v(" "),_("li",[t._v("jwt 有一个过期时间, 过期作废")])])]),t._v(" "),_("h3",{attrs:{id:"优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),_("ul",[_("li",[t._v("无状态, 可多点登录, 允许跨域")]),t._v(" "),_("li",[t._v("不与数据库交互, 更新数据只需要重新签发 jwt, 后端性能好")]),t._v(" "),_("li",[t._v("无需 cookie 存储, 对移动端友好")])]),t._v(" "),_("h3",{attrs:{id:"缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),_("ul",[_("li",[t._v("无状态使得服务端无法主动销毁 jwt, 需要额外的处理\n"),_("ul",[_("li",[t._v("jwt 黑名单机制, 在过期前加入黑名单的将不会被通过")]),t._v(" "),_("li",[t._v("redis 存储, 清除即可销毁 jwt, 但是这样就变得有状态了")]),t._v(" "),_("li",[t._v("较小的过期时间, 这样会使用户频繁登录")])])]),t._v(" "),_("li",[t._v("安全性, 无法避免算法被破解之后, 敏感信息的泄漏")]),t._v(" "),_("li",[t._v("性能, 每次 http 都将携带体积不小的 jwt")]),t._v(" "),_("li",[t._v("refresh, 不能优雅的解决过期时间问题")])]),t._v(" "),_("h2",{attrs:{id:"oauth2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#oauth2"}},[t._v("#")]),t._v(" Oauth2")]),t._v(" "),_("blockquote",[_("p",[t._v("Resource Owner: 用户")]),t._v(" "),_("p",[t._v("Resource Server: 资源服务器, 存放用户数据的地方")]),t._v(" "),_("p",[t._v("Authorization Server: 授权服务器")]),t._v(" "),_("p",[t._v("Client: 第三方应用")])]),t._v(" "),_("h3",{attrs:{id:"运行流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运行流程"}},[t._v("#")]),t._v(" 运行流程")]),t._v(" "),_("blockquote",[_("p",[t._v("（A）用户打开第三方应用以后，要求用户给予授权。\n（B）用户同意给予第三方应用授权。\n（C）第三方应用使用上一步获得的授权，向认证服务器申请令牌。\n（D）认证服务器对第三方应用进行认证以后，确认无误，同意发放令牌。\n（E）第三方应用使用令牌，向资源服务器申请获取资源。\n（F）资源服务器确认令牌无误，同意向第三方应用开放资源。")])]),t._v(" "),_("p",[_("img",{attrs:{src:v(466),alt:"img"}})]),t._v(" "),_("h3",{attrs:{id:"内部实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内部实现"}},[t._v("#")]),t._v(" 内部实现")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("授权服务器负责生成/认证/销毁/刷新授权")]),t._v(" "),_("ol",[_("li",[t._v("生成 accessToken, 存到 redis")]),t._v(" "),_("li",[t._v("认证 accessToken, 提供认证算法, 供网关调用")]),t._v(" "),_("li",[t._v("销毁 accessToken, 直接删除 redis")]),t._v(" "),_("li",[t._v("刷新 accessToken, 利用存活期更长的 refreshTocken 来刷新 accessToken")])])]),t._v(" "),_("li",[_("p",[t._v("网关拦截")]),t._v(" "),_("ol",[_("li",[t._v("通过特定的前缀访问授权服务器, 获取授权")]),t._v(" "),_("li",[t._v("需要认证的请求统统经过网关验证")]),t._v(" "),_("li",[t._v("放行不需要认证的请求")])])])])])}),[],!1,null,null,null);s.default=e.exports}}]);